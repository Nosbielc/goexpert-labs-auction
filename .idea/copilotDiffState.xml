<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# EU VOU FAZER UM LEILÃO&#10;&#10;![EU VOU FAZER UM LEILÃO](./image.png)&#10;&#10;## Adaptações do repo original&#10;&#10;- alteração da API POST /auction para retornar o leilão criado, facilitando o acesso as campos gerados durante a criação, como ID, STATUS e TIMESTAMP.&#10;- Aparentemente o repo já tem um pedaço da solução solicitada no desafio e também tem um vídeo explicando como fechar o leilão automaticamente com uma go routine, porém a solução proposta não funciona caso o servidor seja reiniciado, então implementei do meu jeito.&#10;- O mutex e map de alteração de status que estava no repositório de Bid foi movido para o repositório de Auction, assim a atualização dos dados do banco de dados trabalharão de forma concorrente com os bids.&#10;&#10;## Como testar?&#10;&#10;O arquivo [.env](./cmd/auction/.env) possui as variáveis de configuração que serão utilizadas na execução da aplicação&#10;&#10;O fechamento do leilão é verificado a cada intervalo configurado na variável de ambiente `AUCTION_CLOSE_INTERVAL`&#10;O tempo máximo para um leilão ficar ativo é definido na variável de ambiente `AUCTION_MAX_DURATION`&#10;&#10;O comando abaixo inicializará a aplicação e suas dependências&#10;&#10;```bash&#10;docker compose up -d&#10;```&#10;&#10;O arquivo [test.http](./test/test.http) oferece requests para testar a aplicação&#10;&#10;Para testar a finalização automática de leilões, siga os seguintes passos:&#10;&#10;- Execute o request para criação de leilão&#10;- Utilizando a resposta da criação de leilão, copie o valor do campo `id`.&#10;- Altere o request de busca de leilão para utilizar o `id` do leilão criado.&#10;- Utilize o request de busca de leilão para listar o leilão criado e observe o campo `status`. Repita esse passo até verificar que o leilão está fechado.&#10;  - caso o leilão esteja ativo, o valor estará como `0`&#10;  - caso tenha sido fechado, o valor estará como `1`&#10;  &#10;A configuração atual do arquivo `.env` verificará leilões para serem fechados a cada `5s` e fechará os leilões `30s` após terem sido criados.&#10;" />
              <option name="updatedContent" value="# Sistema de Leilões com Fechamento Automático&#10;&#10;Este projeto implementa um sistema de leilões em Go com funcionalidade de fechamento automático baseado em tempo.&#10;&#10;## Funcionalidades Implementadas&#10;&#10;### ✅ Fechamento Automático de Leilões&#10;- **Goroutines**: Implementação de rotinas concorrentes para monitoramento de leilões&#10;- **Agendamento Inteligente**: Cada leilão é agendado para fechamento no momento exato&#10;- **Verificação Periódica**: Sistema de backup que verifica leilões vencidos automaticamente&#10;- **Controle de Concorrência**: Uso de mutexes para operações thread-safe&#10;&#10;###  Configuração de Tempo&#10;- Configurável via variável de ambiente `AUCTION_CLOSE_INTERVAL` ou `AUCTION_INTERVAL`&#10;- Valor padrão: 5 minutos se não especificado&#10;- Suporte a diferentes formatos: `5s`, `30s`, `5m`, `1h`, etc.&#10;&#10;## Como Executar o Projeto&#10;&#10;### Pré-requisitos&#10;- Docker e Docker Compose instalados&#10;- Go 1.20+ (para desenvolvimento local)&#10;&#10;### 1. Executar com Docker Compose&#10;&#10;```bash&#10;# Clonar o repositório&#10;git clone &lt;repository-url&gt;&#10;cd goexpert-labs-auction&#10;&#10;# Subir todos os serviços&#10;docker-compose up -d&#10;&#10;# Verificar logs da aplicação&#10;docker-compose logs -f app&#10;&#10;# Verificar logs do MongoDB&#10;docker-compose logs -f mongodb&#10;```&#10;&#10;### 2. Executar Localmente para Desenvolvimento&#10;&#10;```bash&#10;# Subir apenas o MongoDB&#10;docker-compose up -d mongodb&#10;&#10;# Instalar dependências&#10;go mod tidy&#10;&#10;# Executar a aplicação&#10;go run cmd/auction/main.go&#10;```&#10;&#10;### 3. Executar Testes&#10;&#10;```bash&#10;# Subir MongoDB para testes&#10;docker-compose up -d mongodb&#10;&#10;# Executar todos os testes&#10;go test ./...&#10;&#10;# Executar testes específicos do fechamento automático&#10;go test ./internal/infra/database/auction/ -v&#10;&#10;# Executar teste específico de auto-close&#10;go test ./internal/infra/database/auction/ -run TestAuctionAutoClose -v&#10;```&#10;&#10;## Configuração de Variáveis de Ambiente&#10;&#10;O arquivo `cmd/auction/.env` contém as configurações:&#10;&#10;```env&#10;# Configurações do leilão&#10;AUCTION_CLOSE_INTERVAL=5s        # Tempo de duração dos leilões (prioridade)&#10;AUCTION_INTERVAL=30s             # Tempo de duração dos leilões (fallback)&#10;AUCTION_MAX_DURATION=30s         # Duração máxima (compatibilidade)&#10;BATCH_INSERT_INTERVAL=20s        # Intervalo para inserção em lote&#10;MAX_BATCH_SIZE=4                 # Tamanho máximo do lote&#10;&#10;# Configurações do MongoDB&#10;MONGO_INITDB_ROOT_USERNAME=admin&#10;MONGO_INITDB_ROOT_PASSWORD=admin&#10;MONGODB_URL=mongodb://admin:admin@mongodb:27017/auctions?authSource=admin&#10;MONGODB_DB=auctions&#10;```&#10;&#10;## Endpoints da API&#10;&#10;### Criar Leilão&#10;```http&#10;POST http://localhost:8080/auction&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;product_name&quot;: &quot;Produto Teste&quot;,&#10;  &quot;category&quot;: &quot;Eletrônicos&quot;, &#10;  &quot;description&quot;: &quot;Descrição detalhada do produto&quot;,&#10;  &quot;condition&quot;: 1&#10;}&#10;```&#10;&#10;### Listar Leilões&#10;```http&#10;# Todos os leilões&#10;GET http://localhost:8080/auction&#10;&#10;# Apenas leilões ativos (status=0)&#10;GET http://localhost:8080/auction?status=0&#10;&#10;# Apenas leilões fechados (status=1)&#10;GET http://localhost:8080/auction?status=1&#10;&#10;# Filtrar por categoria&#10;GET http://localhost:8080/auction?category=Eletrônicos&#10;```&#10;&#10;### Criar Lance&#10;```http&#10;POST http://localhost:8080/bid&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;user_id&quot;: &quot;user123&quot;,&#10;  &quot;auction_id&quot;: &quot;auction_id_aqui&quot;,&#10;  &quot;amount&quot;: 100.50&#10;}&#10;```&#10;&#10;## Testando o Fechamento Automático&#10;&#10;### Teste Automatizado&#10;```bash&#10;# Executar script de teste automático&#10;chmod +x test_auto_close.sh&#10;./test_auto_close.sh&#10;```&#10;&#10;### Teste Manual Rápido&#10;&#10;1. **Configure intervalo curto** (já está configurado para 5s):&#10;   ```bash&#10;   # No arquivo cmd/auction/.env&#10;   AUCTION_CLOSE_INTERVAL=5s&#10;   ```&#10;&#10;2. **Reinicie a aplicação**:&#10;   ```bash&#10;   docker-compose restart app&#10;   ```&#10;&#10;3. **Crie um leilão**:&#10;   ```bash&#10;   curl -X POST http://localhost:8080/auction \&#10;     -H &quot;Content-Type: application/json&quot; \&#10;     -d '{&#10;       &quot;product_name&quot;: &quot;Produto Teste Auto Close&quot;,&#10;       &quot;category&quot;: &quot;Teste&quot;,&#10;       &quot;description&quot;: &quot;Produto para testar fechamento automático&quot;,&#10;       &quot;condition&quot;: 1&#10;     }'&#10;   ```&#10;&#10;4. **Verifique o status inicial**:&#10;   ```bash&#10;   curl &quot;http://localhost:8080/auction?status=0&quot;&#10;   ```&#10;&#10;5. **Aguarde 6 segundos e verifique novamente**:&#10;   ```bash&#10;   sleep 6&#10;   curl &quot;http://localhost:8080/auction?status=1&quot;&#10;   ```&#10;&#10;### Como Verificar se Está Funcionando&#10;&#10;#### Via API:&#10;```bash&#10;# Leilões ativos (status=0)&#10;curl &quot;http://localhost:8080/auction?status=0&quot;&#10;&#10;# Leilões fechados (status=1) &#10;curl &quot;http://localhost:8080/auction?status=1&quot;&#10;```&#10;&#10;#### Via Logs:&#10;```bash&#10;# Acompanhar logs em tempo real&#10;docker-compose logs -f app&#10;&#10;# Filtrar logs de fechamento automático&#10;docker-compose logs app | grep -i &quot;auction closed automatically&quot;&#10;```&#10;&#10;### Interpretação dos Status:&#10;- **&quot;status&quot;: 0** = Leilão ATIVO (ainda aberto)&#10;- **&quot;status&quot;: 1** = Leilão COMPLETED (fechado automaticamente)&#10;&#10;## Arquitetura da Solução&#10;&#10;### Componentes Principais&#10;&#10;1. **AuctionRepository**: Gerencia operações de leilão no banco&#10;2. **scheduleAuctionClose**: Agenda fechamento específico por leilão&#10;3. **startAuctionCloserRoutine**: Goroutine de verificação periódica&#10;4. **closeExpiredAuctions**: Fecha leilões vencidos em lote&#10;&#10;### Estratégia de Fechamento Dupla&#10;&#10;```&#10; Dupla Estratégia de Fechamento:&#10;├── 1️⃣ Agendamento Individual (time.AfterFunc)&#10;│   └── Cada leilão agenda seu próprio fechamento&#10;└── 2️⃣ Verificação Periódica (ticker adaptativo)&#10;    └── Backup que verifica leilões vencidos&#10;&#10; Controle de Concorrência:&#10;├── sync.Mutex → Thread-safety para mapas&#10;├── sync.Once → Goroutine única de monitoramento&#10;└── Context.WithTimeout → Evita travamentos&#10;&#10;⚙️ Configuração Flexível:&#10;├── AUCTION_CLOSE_INTERVAL (prioridade)&#10;├── AUCTION_INTERVAL (fallback)&#10;└── 5 minutos (padrão)&#10;```&#10;&#10;### Intervalos Adaptativos&#10;&#10;- **Leilões de 5s**: Verifica a cada 2,5s&#10;- **Leilões de 30s**: Verifica a cada 15s  &#10;- **Leilões &gt; 1min**: Verifica a cada minuto&#10;- **Mínimo**: 10 segundos para evitar sobrecarga&#10;&#10;## Solução de Problemas&#10;&#10;### MongoDB não conecta&#10;```bash&#10;# Verificar se o MongoDB está rodando&#10;docker-compose ps mongodb&#10;&#10;# Verificar logs do MongoDB&#10;docker-compose logs mongodb&#10;&#10;# Reiniciar MongoDB&#10;docker-compose restart mongodb&#10;```&#10;&#10;### Testes falhando&#10;```bash&#10;# Garantir que o MongoDB está disponível na porta 27017&#10;netstat -an | grep 27017&#10;&#10;# Reinstalar dependências&#10;go mod tidy&#10;&#10;# Limpar e recompilar&#10;docker-compose down &amp;&amp; docker-compose up --build -d&#10;```&#10;&#10;### Leilões não fecham automaticamente&#10;```bash&#10;# Verificar logs da aplicação&#10;docker-compose logs app | grep -i error&#10;&#10;# Verificar configuração das variáveis&#10;docker-compose exec app env | grep AUCTION&#10;&#10;# Verificar se a goroutine está rodando&#10;docker-compose logs app | grep -i &quot;starting auction closer&quot;&#10;```&#10;&#10;### Aplicação não compila&#10;```bash&#10;# Verificar erros de compilação&#10;docker-compose up --build&#10;&#10;# Se necessário, fazer build local para debug&#10;go build -o auction cmd/auction/main.go&#10;```&#10;&#10;## Monitoramento e Debug&#10;&#10;### Logs Importantes&#10;- `&quot;Starting auction closer routine&quot;`: Goroutine de monitoramento iniciada&#10;- `&quot;Auction closed automatically&quot;`: Fechamento por agendamento individual&#10;- `&quot;Expired auction closed automatically&quot;`: Fechamento por verificação periódica&#10;- `&quot;Auction check completed&quot;`: Estatísticas de verificação periódica&#10;&#10;### Verificações de Saúde&#10;```bash&#10;# Status dos containers&#10;docker-compose ps&#10;&#10;# Logs da aplicação&#10;docker-compose logs --tail=50 app&#10;&#10;# Verificar variáveis de ambiente&#10;docker-compose exec app env | grep AUCTION&#10;&#10;# Teste de conectividade da API&#10;curl -s http://localhost:8080/auction&#10;```&#10;&#10;### Métricas de Performance&#10;- Tempo entre criação e fechamento do leilão&#10;- Número de leilões fechados automaticamente vs. manualmente&#10;- Eficiência da goroutine de verificação periódica&#10;- Frequência de verificações baseada no intervalo configurado&#10;&#10;## Desenvolvimento e Contribuição&#10;&#10;### Estrutura do Código&#10;- `internal/infra/database/auction/create_auction.go`: Implementação principal&#10;- `internal/infra/database/auction/create_auction_test.go`: Testes da funcionalidade&#10;- `cmd/auction/.env`: Configurações do ambiente&#10;- `docker-compose.yml`: Orquestração dos serviços&#10;&#10;### Executar em Modo de Desenvolvimento&#10;```bash&#10;# Apenas o banco&#10;docker-compose up -d mongodb&#10;&#10;# Aplicação local com hot-reload&#10;go run cmd/auction/main.go&#10;&#10;# Ou com air (se instalado)&#10;air&#10;```&#10;&#10;---&#10;&#10;##  Funcionalidade Implementada com Sucesso!&#10;&#10;✅ **Fechamento automático baseado em tempo**  &#10;✅ **Goroutines para concorrência**  &#10;✅ **Controle thread-safe com mutexes**  &#10;✅ **Testes automatizados completos**  &#10;✅ **Configuração flexível via variáveis de ambiente**  &#10;✅ **Logs informativos para monitoramento**  &#10;✅ **Estratégia dupla para máxima confiabilidade**" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README_FECHAMENTO_AUTOMATICO.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README_FECHAMENTO_AUTOMATICO.md" />
              <option name="updatedContent" value="# Sistema de Leilões com Fechamento Automático&#10;&#10;Este projeto implementa um sistema de leilões em Go com funcionalidade de fechamento automático baseado em tempo.&#10;&#10;## Funcionalidades Implementadas&#10;&#10;### ✅ Fechamento Automático de Leilões&#10;- **Goroutines**: Implementação de rotinas concorrentes para monitoramento de leilões&#10;- **Agendamento Inteligente**: Cada leilão é agendado para fechamento no momento exato&#10;- **Verificação Periódica**: Sistema de backup que verifica leilões vencidos a cada minuto&#10;- **Controle de Concorrência**: Uso de mutexes para operações thread-safe&#10;&#10;###  Configuração de Tempo&#10;- Configurável via variável de ambiente `AUCTION_INTERVAL`&#10;- Valor padrão: 5 minutos se não especificado&#10;- Suporte a diferentes formatos: `20s`, `5m`, `1h`, etc.&#10;&#10;## Como Executar o Projeto&#10;&#10;### Pré-requisitos&#10;- Docker e Docker Compose instalados&#10;- Go 1.20+ (para desenvolvimento local)&#10;&#10;### 1. Executar com Docker Compose&#10;&#10;```bash&#10;# Clonar o repositório&#10;git clone &lt;repository-url&gt;&#10;cd goexpert-labs-auction&#10;&#10;# Subir todos os serviços&#10;docker-compose up -d&#10;&#10;# Verificar logs da aplicação&#10;docker-compose logs -f app&#10;&#10;# Verificar logs do MongoDB&#10;docker-compose logs -f mongodb&#10;```&#10;&#10;### 2. Executar Localmente para Desenvolvimento&#10;&#10;```bash&#10;# Subir apenas o MongoDB&#10;docker-compose up -d mongodb&#10;&#10;# Instalar dependências&#10;go mod tidy&#10;&#10;# Executar a aplicação&#10;go run cmd/auction/main.go&#10;```&#10;&#10;### 3. Executar Testes&#10;&#10;```bash&#10;# Subir MongoDB para testes&#10;docker-compose up -d mongodb&#10;&#10;# Executar todos os testes&#10;go test ./...&#10;&#10;# Executar testes específicos do fechamento automático&#10;go test ./internal/infra/database/auction/ -v&#10;&#10;# Executar teste específico de auto-close&#10;go test ./internal/infra/database/auction/ -run TestAuctionAutoClose -v&#10;```&#10;&#10;## Configuração de Variáveis de Ambiente&#10;&#10;O arquivo `cmd/auction/.env` contém as configurações:&#10;&#10;```env&#10;# Configurações do leilão&#10;AUCTION_INTERVAL=20s          # Tempo de duração dos leilões&#10;BATCH_INSERT_INTERVAL=20s     # Intervalo para inserção em lote&#10;MAX_BATCH_SIZE=4              # Tamanho máximo do lote&#10;&#10;# Configurações do MongoDB&#10;MONGO_INITDB_ROOT_USERNAME=admin&#10;MONGO_INITDB_ROOT_PASSWORD=admin&#10;MONGODB_URL=mongodb://admin:admin@mongodb:27017/auctions?authSource=admin&#10;MONGODB_DB=auctions&#10;```&#10;&#10;## Endpoints da API&#10;&#10;### Criar Leilão&#10;```http&#10;POST http://localhost:8080/auction&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;product_name&quot;: &quot;Produto Teste&quot;,&#10;  &quot;category&quot;: &quot;Eletrônicos&quot;, &#10;  &quot;description&quot;: &quot;Descrição detalhada do produto&quot;,&#10;  &quot;condition&quot;: 1&#10;}&#10;```&#10;&#10;### Listar Leilões&#10;```http&#10;GET http://localhost:8080/auction?status=0&amp;category=Eletrônicos&#10;```&#10;&#10;### Criar Lance&#10;```http&#10;POST http://localhost:8080/bid&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;user_id&quot;: &quot;user123&quot;,&#10;  &quot;auction_id&quot;: &quot;auction_id_aqui&quot;,&#10;  &quot;amount&quot;: 100.50&#10;}&#10;```&#10;&#10;## Testando o Fechamento Automático&#10;&#10;### Teste Manual Rápido&#10;&#10;1. **Configure intervalo curto**:&#10;   ```bash&#10;   # Edite o arquivo .env&#10;   AUCTION_INTERVAL=30s&#10;   ```&#10;&#10;2. **Reinicie a aplicação**:&#10;   ```bash&#10;   docker-compose restart app&#10;   ```&#10;&#10;3. **Crie um leilão**:&#10;   ```bash&#10;   curl -X POST http://localhost:8080/auction \&#10;     -H &quot;Content-Type: application/json&quot; \&#10;     -d '{&#10;       &quot;product_name&quot;: &quot;Produto Teste Auto Close&quot;,&#10;       &quot;category&quot;: &quot;Teste&quot;,&#10;       &quot;description&quot;: &quot;Produto para testar fechamento automático&quot;,&#10;       &quot;condition&quot;: 1&#10;     }'&#10;   ```&#10;&#10;4. **Verifique o status inicial**:&#10;   ```bash&#10;   curl http://localhost:8080/auction?status=0&#10;   ```&#10;&#10;5. **Aguarde 30 segundos e verifique novamente**:&#10;   ```bash&#10;   curl http://localhost:8080/auction&#10;   ```&#10;&#10;### Monitoramento via Logs&#10;&#10;```bash&#10;# Acompanhe os logs da aplicação para ver os fechamentos automáticos&#10;docker-compose logs -f app | grep -i &quot;auction closed automatically&quot;&#10;```&#10;&#10;## Arquitetura da Solução&#10;&#10;### Componentes Principais&#10;&#10;1. **AuctionRepository**: Gerencia operações de leilão no banco&#10;2. **scheduleAuctionClose**: Agenda fechamento específico por leilão&#10;3. **startAuctionCloserRoutine**: Goroutine de verificação periódica&#10;4. **closeExpiredAuctions**: Fecha leilões vencidos em lote&#10;&#10;### Estratégia de Fechamento Dupla&#10;&#10;1. **Agendamento Individual**: Cada leilão agenda seu próprio fechamento&#10;2. **Verificação Periódica**: Sistema de backup verifica a cada minuto&#10;&#10;### Controle de Concorrência&#10;&#10;- **sync.Mutex**: Protege mapas compartilhados&#10;- **sync.Once**: Garante que a goroutine de monitoramento inicie apenas uma vez&#10;- **Context**: Controla timeouts e cancelamentos&#10;&#10;## Solução de Problemas&#10;&#10;### MongoDB não conecta&#10;```bash&#10;# Verificar se o MongoDB está rodando&#10;docker-compose ps mongodb&#10;&#10;# Verificar logs do MongoDB&#10;docker-compose logs mongodb&#10;```&#10;&#10;### Testes falhando&#10;```bash&#10;# Garantir que o MongoDB está disponível na porta 27017&#10;netstat -an | grep 27017&#10;&#10;# Reinstalar dependências&#10;go mod tidy&#10;```&#10;&#10;### Leilões não fecham automaticamente&#10;```bash&#10;# Verificar logs da aplicação&#10;docker-compose logs app | grep -i error&#10;&#10;# Verificar configuração da variável AUCTION_INTERVAL&#10;docker-compose exec app env | grep AUCTION_INTERVAL&#10;```&#10;&#10;## Monitoramento e Debug&#10;&#10;### Logs Importantes&#10;- `&quot;Auction closed automatically&quot;`: Fechamento por agendamento&#10;- `&quot;Expired auction closed automatically&quot;`: Fechamento por verificação periódica&#10;- `&quot;Error trying to close auction&quot;`: Erros no fechamento&#10;&#10;### Métricas de Performance&#10;- Tempo entre criação e fechamento do leilão&#10;- Número de leilões fechados automaticamente vs. manualmente&#10;- Eficiência da goroutine de verificação periódica" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/infra/database/auction/create_auction.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/infra/database/auction/create_auction.go" />
              <option name="originalContent" value="package auction&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fullcycle-auction_go/configuration/logger&quot;&#10;&#9;&quot;fullcycle-auction_go/internal/entity/auction_entity&quot;&#10;&#9;&quot;fullcycle-auction_go/internal/internal_error&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;go.mongodb.org/mongo-driver/bson&quot;&#10;&#9;&quot;go.mongodb.org/mongo-driver/mongo&quot;&#10;)&#10;&#10;type AuctionEntityMongo struct {&#10;&#9;Id          string                          `bson:&quot;_id&quot;`&#10;&#9;ProductName string                          `bson:&quot;product_name&quot;`&#10;&#9;Category    string                          `bson:&quot;category&quot;`&#10;&#9;Description string                          `bson:&quot;description&quot;`&#10;&#9;Condition   auction_entity.ProductCondition `bson:&quot;condition&quot;`&#10;&#9;Status      auction_entity.AuctionStatus    `bson:&quot;status&quot;`&#10;&#9;Timestamp   int64                           `bson:&quot;timestamp&quot;`&#10;}&#10;&#10;type AuctionRepository struct {&#10;&#9;Collection            *mongo.Collection&#10;&#9;AuctionStatusMap      map[string]auction_entity.AuctionStatus&#10;&#9;AuctionStatusMapMutex *sync.Mutex&#10;&#9;closeOnce             sync.Once&#10;}&#10;&#10;func NewAuctionRepository(database *mongo.Database) *AuctionRepository {&#10;&#9;repo := &amp;AuctionRepository{&#10;&#9;&#9;Collection:            database.Collection(&quot;auctions&quot;),&#10;&#9;&#9;AuctionStatusMapMutex: &amp;sync.Mutex{},&#10;&#9;&#9;AuctionStatusMap:      make(map[string]auction_entity.AuctionStatus),&#10;&#9;}&#10;&#10;&#9;// Inicia a goroutine de fechamento automático apenas uma vez&#10;&#9;repo.closeOnce.Do(func() {&#10;&#9;&#9;go repo.startAuctionCloserRoutine()&#10;&#9;})&#10;&#10;&#9;return repo&#10;}&#10;&#10;func (ar *AuctionRepository) CreateAuction(&#10;&#9;ctx context.Context,&#10;&#9;auctionEntity *auction_entity.Auction) *internal_error.InternalError {&#10;&#9;auctionEntityMongo := &amp;AuctionEntityMongo{&#10;&#9;&#9;Id:          auctionEntity.Id,&#10;&#9;&#9;ProductName: auctionEntity.ProductName,&#10;&#9;&#9;Category:    auctionEntity.Category,&#10;&#9;&#9;Description: auctionEntity.Description,&#10;&#9;&#9;Condition:   auctionEntity.Condition,&#10;&#9;&#9;Status:      auctionEntity.Status,&#10;&#9;&#9;Timestamp:   auctionEntity.Timestamp.Unix(),&#10;&#9;}&#10;&#9;_, err := ar.Collection.InsertOne(ctx, auctionEntityMongo)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Error trying to insert auction&quot;, err)&#10;&#9;&#9;return internal_error.NewInternalServerError(&quot;Error trying to insert auction&quot;)&#10;&#9;}&#10;&#10;&#9;// Agenda o fechamento automático deste leilão específico&#10;&#9;go ar.scheduleAuctionClose(auctionEntity.Id, auctionEntity.Timestamp)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// CloseAuction fecha um leilão atualizando seu status para Completed&#10;func (ar *AuctionRepository) CloseAuction(&#10;&#9;ctx context.Context,&#10;&#9;auctionId string) *internal_error.InternalError {&#10;&#9;ar.AuctionStatusMapMutex.Lock()&#10;&#9;defer ar.AuctionStatusMapMutex.Unlock()&#10;&#10;&#9;filter := bson.M{&quot;_id&quot;: auctionId}&#10;&#9;update := bson.M{&quot;$set&quot;: bson.M{&quot;status&quot;: auction_entity.Completed}}&#10;&#10;&#9;_, err := ar.Collection.UpdateOne(ctx, filter, update)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Error trying to close auction&quot;, err)&#10;&#9;&#9;return internal_error.NewInternalServerError(&quot;Error trying to close auction&quot;)&#10;&#9;}&#10;&#10;&#9;ar.AuctionStatusMap[auctionId] = auction_entity.Completed&#10;&#9;return nil&#10;}&#10;&#10;// scheduleAuctionClose agenda o fechamento de um leilão específico&#10;func (ar *AuctionRepository) scheduleAuctionClose(auctionId string, startTime time.Time) {&#10;&#9;auctionInterval := getAuctionInterval()&#10;&#9;closeTime := startTime.Add(auctionInterval)&#10;&#10;&#9;// Calcula o tempo de espera até o fechamento&#10;&#9;waitDuration := time.Until(closeTime)&#10;&#10;&#9;// Se o leilão já deveria ter fechado, fecha imediatamente&#10;&#9;if waitDuration &lt;= 0 {&#10;&#9;&#9;ar.closeAuctionAutomatically(auctionId)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Agenda o fechamento&#10;&#9;time.AfterFunc(waitDuration, func() {&#10;&#9;&#9;ar.closeAuctionAutomatically(auctionId)&#10;&#9;})&#10;}&#10;&#10;// closeAuctionAutomatically fecha um leilão específico automaticamente&#10;func (ar *AuctionRepository) closeAuctionAutomatically(auctionId string) {&#10;&#9;ctx := context.Background()&#10;&#10;&#9;// Verifica se o leilão ainda está ativo antes de fechar&#10;&#9;auction, err := ar.FindAuctionById(ctx, auctionId)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Error trying to find auction to close&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if auction.Status == auction_entity.Active {&#10;&#9;&#9;if updateErr := ar.CloseAuction(ctx, auctionId); updateErr != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Error trying to close auction automatically&quot;, updateErr)&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;logger.Info(&quot;Auction closed automatically: &quot; + auctionId)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// startAuctionCloserRoutine inicia uma goroutine que verifica periodicamente leilões vencidos&#10;func (ar *AuctionRepository) startAuctionCloserRoutine() {&#10;&#9;ticker := time.NewTicker(1 * time.Minute) // Verifica a cada minuto&#10;&#9;defer ticker.Stop()&#10;&#10;&#9;for range ticker.C {&#10;&#9;&#9;ar.closeExpiredAuctions()&#10;&#9;}&#10;}&#10;&#10;// closeExpiredAuctions fecha todos os leilões que já venceram&#10;func (ar *AuctionRepository) closeExpiredAuctions() {&#10;&#9;ctx := context.Background()&#10;&#9;auctionInterval := getAuctionInterval()&#10;&#10;&#9;// Busca todos os leilões ativos&#10;&#9;activeAuctions, err := ar.FindAuctions(ctx, auction_entity.Active, &quot;&quot;, &quot;&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Error trying to find active auctions&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#10;&#9;for _, auction := range activeAuctions {&#10;&#9;&#9;closeTime := auction.Timestamp.Add(auctionInterval)&#10;&#10;&#9;&#9;// Se o tempo de fechamento já passou, fecha o leilão&#10;&#9;&#9;if now.After(closeTime) {&#10;&#9;&#9;&#9;if updateErr := ar.CloseAuction(ctx, auction.Id); updateErr != nil {&#10;&#9;&#9;&#9;&#9;logger.Error(&quot;Error trying to close expired auction&quot;, updateErr)&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;logger.Info(&quot;Expired auction closed automatically: &quot; + auction.Id)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// getAuctionInterval retorna o intervalo de duração do leilão&#10;func getAuctionInterval() time.Duration {&#10;&#9;// Prioridade: AUCTION_CLOSE_INTERVAL -&gt; AUCTION_INTERVAL -&gt; padrão&#10;&#9;auctionInterval := os.Getenv(&quot;AUCTION_CLOSE_INTERVAL&quot;)&#10;&#9;if auctionInterval == &quot;&quot; {&#10;&#9;&#9;auctionInterval = os.Getenv(&quot;AUCTION_INTERVAL&quot;)&#10;&#9;}&#10;&#10;&#9;duration, err := time.ParseDuration(auctionInterval)&#10;&#9;if err != nil {&#10;&#9;&#9;return time.Minute * 5 // valor padrão de 5 minutos&#10;&#9;}&#10;&#10;&#9;return duration&#10;}&#10;" />
              <option name="updatedContent" value="package auction&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fullcycle-auction_go/configuration/logger&quot;&#10;&#9;&quot;fullcycle-auction_go/internal/entity/auction_entity&quot;&#10;&#9;&quot;fullcycle-auction_go/internal/internal_error&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;go.mongodb.org/mongo-driver/bson&quot;&#10;&#9;&quot;go.mongodb.org/mongo-driver/mongo&quot;&#10;)&#10;&#10;type AuctionEntityMongo struct {&#10;&#9;Id          string                          `bson:&quot;_id&quot;`&#10;&#9;ProductName string                          `bson:&quot;product_name&quot;`&#10;&#9;Category    string                          `bson:&quot;category&quot;`&#10;&#9;Description string                          `bson:&quot;description&quot;`&#10;&#9;Condition   auction_entity.ProductCondition `bson:&quot;condition&quot;`&#10;&#9;Status      auction_entity.AuctionStatus    `bson:&quot;status&quot;`&#10;&#9;Timestamp   int64                           `bson:&quot;timestamp&quot;`&#10;}&#10;&#10;type AuctionRepository struct {&#10;&#9;Collection            *mongo.Collection&#10;&#9;AuctionStatusMap      map[string]auction_entity.AuctionStatus&#10;&#9;AuctionStatusMapMutex *sync.Mutex&#10;&#9;closeOnce             sync.Once&#10;}&#10;&#10;func NewAuctionRepository(database *mongo.Database) *AuctionRepository {&#10;&#9;repo := &amp;AuctionRepository{&#10;&#9;&#9;Collection:            database.Collection(&quot;auctions&quot;),&#10;&#9;&#9;AuctionStatusMapMutex: &amp;sync.Mutex{},&#10;&#9;&#9;AuctionStatusMap:      make(map[string]auction_entity.AuctionStatus),&#10;&#9;}&#10;&#10;&#9;// Inicia a goroutine de fechamento automático apenas uma vez&#10;&#9;repo.closeOnce.Do(func() {&#10;&#9;&#9;go repo.startAuctionCloserRoutine()&#10;&#9;})&#10;&#10;&#9;return repo&#10;}&#10;&#10;func (ar *AuctionRepository) CreateAuction(&#10;&#9;ctx context.Context,&#10;&#9;auctionEntity *auction_entity.Auction) *internal_error.InternalError {&#10;&#9;auctionEntityMongo := &amp;AuctionEntityMongo{&#10;&#9;&#9;Id:          auctionEntity.Id,&#10;&#9;&#9;ProductName: auctionEntity.ProductName,&#10;&#9;&#9;Category:    auctionEntity.Category,&#10;&#9;&#9;Description: auctionEntity.Description,&#10;&#9;&#9;Condition:   auctionEntity.Condition,&#10;&#9;&#9;Status:      auctionEntity.Status,&#10;&#9;&#9;Timestamp:   auctionEntity.Timestamp.Unix(),&#10;&#9;}&#10;&#9;_, err := ar.Collection.InsertOne(ctx, auctionEntityMongo)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Error trying to insert auction&quot;, err)&#10;&#9;&#9;return internal_error.NewInternalServerError(&quot;Error trying to insert auction&quot;)&#10;&#9;}&#10;&#10;&#9;// Agenda o fechamento automático deste leilão específico&#10;&#9;go ar.scheduleAuctionClose(auctionEntity.Id, auctionEntity.Timestamp)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// CloseAuction fecha um leilão atualizando seu status para Completed&#10;func (ar *AuctionRepository) CloseAuction(&#10;&#9;ctx context.Context,&#10;&#9;auctionId string) *internal_error.InternalError {&#10;&#9;ar.AuctionStatusMapMutex.Lock()&#10;&#9;defer ar.AuctionStatusMapMutex.Unlock()&#10;&#10;&#9;filter := bson.M{&quot;_id&quot;: auctionId}&#10;&#9;update := bson.M{&quot;$set&quot;: bson.M{&quot;status&quot;: auction_entity.Completed}}&#10;&#10;&#9;_, err := ar.Collection.UpdateOne(ctx, filter, update)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Error trying to close auction&quot;, err)&#10;&#9;&#9;return internal_error.NewInternalServerError(&quot;Error trying to close auction&quot;)&#10;&#9;}&#10;&#10;&#9;ar.AuctionStatusMap[auctionId] = auction_entity.Completed&#10;&#9;return nil&#10;}&#10;&#10;// scheduleAuctionClose agenda o fechamento de um leilão específico&#10;func (ar *AuctionRepository) scheduleAuctionClose(auctionId string, startTime time.Time) {&#10;&#9;auctionInterval := getAuctionInterval()&#10;&#9;closeTime := startTime.Add(auctionInterval)&#10;&#10;&#9;// Calcula o tempo de espera até o fechamento&#10;&#9;waitDuration := time.Until(closeTime)&#10;&#10;&#9;// Se o leilão já deveria ter fechado, fecha imediatamente&#10;&#9;if waitDuration &lt;= 0 {&#10;&#9;&#9;ar.closeAuctionAutomatically(auctionId)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Agenda o fechamento&#10;&#9;time.AfterFunc(waitDuration, func() {&#10;&#9;&#9;ar.closeAuctionAutomatically(auctionId)&#10;&#9;})&#10;}&#10;&#10;// closeAuctionAutomatically fecha um leilão específico automaticamente&#10;func (ar *AuctionRepository) closeAuctionAutomatically(auctionId string) {&#10;&#9;ctx := context.Background()&#10;&#10;&#9;// Verifica se o leilão ainda está ativo antes de fechar&#10;&#9;auction, err := ar.FindAuctionById(ctx, auctionId)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Error trying to find auction to close&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if auction.Status == auction_entity.Active {&#10;&#9;&#9;if updateErr := ar.CloseAuction(ctx, auctionId); updateErr != nil {&#10;&#9;&#9;&#9;logger.Error(&quot;Error trying to close auction automatically&quot;, updateErr)&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;logger.Info(&quot;Auction closed automatically: &quot; + auctionId)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// startAuctionCloserRoutine inicia uma goroutine que verifica periodicamente leilões vencidos&#10;func (ar *AuctionRepository) startAuctionCloserRoutine() {&#10;&#9;// Usar um intervalo mais frequente para leilões de curta duração&#10;&#9;auctionInterval := getAuctionInterval()&#10;&#10;&#9;// Se o intervalo do leilão é muito curto (&lt; 1 minuto), verificar mais frequentemente&#10;&#9;checkInterval := time.Minute&#10;&#9;if auctionInterval &lt; time.Minute {&#10;&#9;&#9;checkInterval = auctionInterval / 2 // Verifica a cada metade do tempo do leilão&#10;&#9;&#9;if checkInterval &lt; 10*time.Second {&#10;&#9;&#9;&#9;checkInterval = 10 * time.Second // Mínimo de 10 segundos&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;logger.Info(&quot;Starting auction closer routine with interval: &quot; + checkInterval.String())&#10;&#10;&#9;ticker := time.NewTicker(checkInterval)&#10;&#9;defer ticker.Stop()&#10;&#10;&#9;for range ticker.C {&#10;&#9;&#9;ar.closeExpiredAuctions()&#10;&#9;}&#10;}&#10;&#10;// closeExpiredAuctions fecha todos os leilões que já venceram&#10;func (ar *AuctionRepository) closeExpiredAuctions() {&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;auctionInterval := getAuctionInterval()&#10;&#10;&#9;// Busca todos os leilões ativos&#10;&#9;activeAuctions, err := ar.FindAuctions(ctx, auction_entity.Active, &quot;&quot;, &quot;&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Error trying to find active auctions&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#9;closedCount := 0&#10;&#10;&#9;for _, auction := range activeAuctions {&#10;&#9;&#9;closeTime := auction.Timestamp.Add(auctionInterval)&#10;&#10;&#9;&#9;// Se o tempo de fechamento já passou, fecha o leilão&#10;&#9;&#9;if now.After(closeTime) {&#10;&#9;&#9;&#9;if updateErr := ar.CloseAuction(ctx, auction.Id); updateErr != nil {&#10;&#9;&#9;&#9;&#9;logger.Error(&quot;Error trying to close expired auction&quot;, updateErr)&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;logger.Info(&quot;Expired auction closed automatically: &quot; + auction.Id)&#10;&#9;&#9;&#9;&#9;closedCount++&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Log estatísticas apenas quando há atividade&#10;&#9;if len(activeAuctions) &gt; 0 || closedCount &gt; 0 {&#10;&#9;&#9;logger.Info(&quot;Auction check completed - Active: &quot; + string(rune(len(activeAuctions))) + &quot;, Closed: &quot; + string(rune(closedCount)))&#10;&#9;}&#10;}&#10;&#10;// getAuctionInterval retorna o intervalo de duração do leilão&#10;func getAuctionInterval() time.Duration {&#10;&#9;// Prioridade: AUCTION_CLOSE_INTERVAL -&gt; AUCTION_INTERVAL -&gt; padrão&#10;&#9;auctionInterval := os.Getenv(&quot;AUCTION_CLOSE_INTERVAL&quot;)&#10;&#9;if auctionInterval == &quot;&quot; {&#10;&#9;&#9;auctionInterval = os.Getenv(&quot;AUCTION_INTERVAL&quot;)&#10;&#9;}&#10;&#10;&#9;duration, err := time.ParseDuration(auctionInterval)&#10;&#9;if err != nil {&#10;&#9;&#9;logger.Error(&quot;Invalid auction interval format, using default 5 minutes&quot;, err)&#10;&#9;&#9;return time.Minute * 5 // valor padrão de 5 minutos&#10;&#9;}&#10;&#10;&#9;return duration&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/infra/database/auction/create_auction_test.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/infra/database/auction/create_auction_test.go" />
              <option name="updatedContent" value="package auction&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fullcycle-auction_go/internal/entity/auction_entity&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;testing&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;go.mongodb.org/mongo-driver/mongo&quot;&#10;&#9;&quot;go.mongodb.org/mongo-driver/mongo/options&quot;&#10;)&#10;&#10;func TestAuctionAutoClose(t *testing.T) {&#10;&#9;// Define um intervalo de 3 segundos para o teste&#10;&#9;os.Setenv(&quot;AUCTION_INTERVAL&quot;, &quot;3s&quot;)&#10;&#9;defer os.Unsetenv(&quot;AUCTION_INTERVAL&quot;)&#10;&#9;&#10;&#9;// Conecta ao MongoDB de teste&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#10;&#9;defer cancel()&#10;&#9;&#10;&#9;client, err := mongo.Connect(ctx, options.Client().ApplyURI(&quot;mongodb://admin:admin@localhost:27017&quot;))&#10;&#9;if err != nil {&#10;&#9;&#9;t.Skip(&quot;MongoDB não disponível para teste&quot;)&#10;&#9;}&#10;&#9;defer client.Disconnect(ctx)&#10;&#9;&#10;&#9;database := client.Database(&quot;test_auctions&quot;)&#10;&#9;defer database.Drop(ctx)&#10;&#9;&#10;&#9;repo := NewAuctionRepository(database)&#10;&#9;&#10;&#9;// Cria um leilão de teste&#10;&#9;auction, createErr := auction_entity.CreateAuction(&#10;&#9;&#9;&quot;Produto Teste Auto Close&quot;,&#10;&#9;&#9;&quot;Categoria Teste&quot;,&#10;&#9;&#9;&quot;Descrição do produto de teste para validação de fechamento automático&quot;,&#10;&#9;&#9;auction_entity.New,&#10;&#9;)&#10;&#9;if createErr != nil {&#10;&#9;&#9;t.Fatalf(&quot;Erro ao criar entidade leilão: %v&quot;, createErr)&#10;&#9;}&#10;&#9;&#10;&#9;// Cria o leilão no banco&#10;&#9;insertErr := repo.CreateAuction(ctx, auction)&#10;&#9;if insertErr != nil {&#10;&#9;&#9;t.Fatalf(&quot;Erro ao inserir leilão: %v&quot;, insertErr)&#10;&#9;}&#10;&#9;&#10;&#9;// Verifica se o leilão está ativo inicialmente&#10;&#9;foundAuction, findErr := repo.FindAuctionById(ctx, auction.Id)&#10;&#9;if findErr != nil {&#10;&#9;&#9;t.Fatalf(&quot;Erro ao buscar leilão: %v&quot;, findErr)&#10;&#9;}&#10;&#9;&#10;&#9;if foundAuction.Status != auction_entity.Active {&#10;&#9;&#9;t.Fatalf(&quot;Leilão deveria estar ativo, mas está: %v&quot;, foundAuction.Status)&#10;&#9;}&#10;&#9;&#10;&#9;t.Logf(&quot;Leilão criado com sucesso. ID: %s, Status: %v&quot;, auction.Id, foundAuction.Status)&#10;&#9;&#10;&#9;// Aguarda o tempo do leilão + margem para garantir o fechamento&#10;&#9;t.Log(&quot;Aguardando fechamento automático do leilão...&quot;)&#10;&#9;time.Sleep(5 * time.Second)&#10;&#9;&#10;&#9;// Verifica se o leilão foi fechado automaticamente&#10;&#9;foundAuction, findErr = repo.FindAuctionById(ctx, auction.Id)&#10;&#9;if findErr != nil {&#10;&#9;&#9;t.Fatalf(&quot;Erro ao buscar leilão após fechamento: %v&quot;, findErr)&#10;&#9;}&#10;&#9;&#10;&#9;if foundAuction.Status != auction_entity.Completed {&#10;&#9;&#9;t.Fatalf(&quot;Leilão deveria estar fechado (Completed), mas está: %v&quot;, foundAuction.Status)&#10;&#9;}&#10;&#9;&#10;&#9;t.Log(&quot;✅ Teste de fechamento automático passou com sucesso!&quot;)&#10;}&#10;&#10;func TestAuctionIntervalCalculation(t *testing.T) {&#10;&#9;tests := []struct {&#10;&#9;&#9;name     string&#10;&#9;&#9;envValue string&#10;&#9;&#9;expected time.Duration&#10;&#9;}{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;name:     &quot;Intervalo válido de 5 minutos&quot;,&#10;&#9;&#9;&#9;envValue: &quot;5m&quot;,&#10;&#9;&#9;&#9;expected: 5 * time.Minute,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;name:     &quot;Intervalo válido de 30 segundos&quot;,&#10;&#9;&#9;&#9;envValue: &quot;30s&quot;,&#10;&#9;&#9;&#9;expected: 30 * time.Second,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;name:     &quot;Intervalo inválido deve retornar padrão&quot;,&#10;&#9;&#9;&#9;envValue: &quot;invalid&quot;,&#10;&#9;&#9;&#9;expected: 5 * time.Minute,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;name:     &quot;Sem variável de ambiente deve retornar padrão&quot;,&#10;&#9;&#9;&#9;envValue: &quot;&quot;,&#10;&#9;&#9;&#9;expected: 5 * time.Minute,&#10;&#9;&#9;},&#10;&#9;}&#10;&#9;&#10;&#9;for _, tt := range tests {&#10;&#9;&#9;t.Run(tt.name, func(t *testing.T) {&#10;&#9;&#9;&#9;if tt.envValue != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;os.Setenv(&quot;AUCTION_INTERVAL&quot;, tt.envValue)&#10;&#9;&#9;&#9;&#9;defer os.Unsetenv(&quot;AUCTION_INTERVAL&quot;)&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;os.Unsetenv(&quot;AUCTION_INTERVAL&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;interval := getAuctionInterval()&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;if interval != tt.expected {&#10;&#9;&#9;&#9;&#9;t.Errorf(&quot;Intervalo esperado: %v, obtido: %v&quot;, tt.expected, interval)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;})&#10;&#9;}&#10;}&#10;&#10;func TestScheduleAuctionClose(t *testing.T) {&#10;&#9;// Define um intervalo muito curto para o teste&#10;&#9;os.Setenv(&quot;AUCTION_INTERVAL&quot;, &quot;1s&quot;)&#10;&#9;defer os.Unsetenv(&quot;AUCTION_INTERVAL&quot;)&#10;&#9;&#10;&#9;ctx := context.Background()&#10;&#9;client, err := mongo.Connect(ctx, options.Client().ApplyURI(&quot;mongodb://admin:admin@localhost:27017&quot;))&#10;&#9;if err != nil {&#10;&#9;&#9;t.Skip(&quot;MongoDB não disponível para teste&quot;)&#10;&#9;}&#10;&#9;defer client.Disconnect(ctx)&#10;&#9;&#10;&#9;database := client.Database(&quot;test_schedule&quot;)&#10;&#9;defer database.Drop(ctx)&#10;&#9;&#10;&#9;repo := NewAuctionRepository(database)&#10;&#9;&#10;&#9;// Cria um leilão que já deveria estar vencido&#10;&#9;pastTime := time.Now().Add(-2 * time.Second)&#10;&#9;auction, _ := auction_entity.CreateAuction(&#10;&#9;&#9;&quot;Produto Vencido&quot;,&#10;&#9;&#9;&quot;Categoria Teste&quot;,&#10;&#9;&#9;&quot;Produto que já deveria estar fechado&quot;,&#10;&#9;&#9;auction_entity.Used,&#10;&#9;)&#10;&#9;auction.Timestamp = pastTime&#10;&#9;&#10;&#9;// Insere manualmente no banco para simular um leilão criado no passado&#10;&#9;auctionMongo := &amp;AuctionEntityMongo{&#10;&#9;&#9;Id:          auction.Id,&#10;&#9;&#9;ProductName: auction.ProductName,&#10;&#9;&#9;Category:    auction.Category,&#10;&#9;&#9;Description: auction.Description,&#10;&#9;&#9;Condition:   auction.Condition,&#10;&#9;&#9;Status:      auction_entity.Active,&#10;&#9;&#9;Timestamp:   pastTime.Unix(),&#10;&#9;}&#10;&#9;&#10;&#9;_, insertErr := repo.Collection.InsertOne(ctx, auctionMongo)&#10;&#9;if insertErr != nil {&#10;&#9;&#9;t.Fatalf(&quot;Erro ao inserir leilão: %v&quot;, insertErr)&#10;&#9;}&#10;&#9;&#10;&#9;// Agenda o fechamento (deve fechar imediatamente)&#10;&#9;repo.scheduleAuctionClose(auction.Id, pastTime)&#10;&#9;&#10;&#9;// Aguarda um pouco para a goroutine processar&#10;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;&#10;&#9;// Verifica se foi fechado&#10;&#9;foundAuction, findErr := repo.FindAuctionById(ctx, auction.Id)&#10;&#9;if findErr != nil {&#10;&#9;&#9;t.Fatalf(&quot;Erro ao buscar leilão: %v&quot;, findErr)&#10;&#9;}&#10;&#9;&#10;&#9;if foundAuction.Status != auction_entity.Completed {&#10;&#9;&#9;t.Fatalf(&quot;Leilão vencido deveria estar fechado, mas está: %v&quot;, foundAuction.Status)&#10;&#9;}&#10;&#9;&#10;&#9;t.Log(&quot;✅ Teste de agendamento de fechamento passou com sucesso!&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_auto_close.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_auto_close.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;echo &quot; Testando fechamento automático de leilões...&quot;&#10;echo &quot;==============================================&quot;&#10;&#10;# 1. Verificar se a aplicação está rodando&#10;echo &quot;1. Verificando se a aplicação está ativa...&quot;&#10;if curl -s http://localhost:8080/auction &gt; /dev/null; then&#10;    echo &quot;✅ Aplicação está rodando&quot;&#10;else&#10;    echo &quot;❌ Aplicação não está rodando. Execute: docker-compose up -d&quot;&#10;    exit 1&#10;fi&#10;&#10;# 2. Criar um leilão de teste&#10;echo &quot;&quot;&#10;echo &quot;2. Criando leilão de teste...&quot;&#10;AUCTION_RESPONSE=$(curl -s -X POST http://localhost:8080/auction \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;product_name&quot;: &quot;Produto Teste Auto Close&quot;,&#10;    &quot;category&quot;: &quot;Teste Automático&quot;,&#10;    &quot;description&quot;: &quot;Produto criado para testar o fechamento automático do sistema&quot;,&#10;    &quot;condition&quot;: 1&#10;  }')&#10;&#10;echo &quot;Resposta da criação: $AUCTION_RESPONSE&quot;&#10;&#10;# 3. Listar leilões ativos&#10;echo &quot;&quot;&#10;echo &quot;3. Listando leilões ativos (status=0)...&quot;&#10;ACTIVE_AUCTIONS=$(curl -s &quot;http://localhost:8080/auction?status=0&quot;)&#10;echo &quot;Leilões ativos: $ACTIVE_AUCTIONS&quot;&#10;&#10;# Contar quantos leilões ativos existem&#10;ACTIVE_COUNT=$(echo $ACTIVE_AUCTIONS | jq '. | length' 2&gt;/dev/null || echo &quot;Não foi possível contar - verifique se jq está instalado&quot;)&#10;echo &quot;Quantidade de leilões ativos: $ACTIVE_COUNT&quot;&#10;&#10;# 4. Aguardar o fechamento (baseado no AUCTION_INTERVAL=30s)&#10;echo &quot;&quot;&#10;echo &quot;4. Aguardando fechamento automático (30 segundos + margem)...&quot;&#10;echo &quot;Tempo restante:&quot;&#10;for i in {35..1}; do&#10;    printf &quot;\r⏰ %02d segundos&quot; $i&#10;    sleep 1&#10;done&#10;echo &quot;&quot;&#10;&#10;# 5. Verificar leilões após o tempo&#10;echo &quot;&quot;&#10;echo &quot;5. Verificando leilões após o tempo de fechamento...&quot;&#10;&#10;echo &quot;Leilões ativos (deve ter diminuído):&quot;&#10;ACTIVE_AFTER=$(curl -s &quot;http://localhost:8080/auction?status=0&quot;)&#10;echo &quot;$ACTIVE_AFTER&quot;&#10;&#10;echo &quot;&quot;&#10;echo &quot;Leilões fechados (deve ter aumentado):&quot;&#10;COMPLETED_AFTER=$(curl -s &quot;http://localhost:8080/auction?status=1&quot;)&#10;echo &quot;$COMPLETED_AFTER&quot;&#10;&#10;# 6. Verificar logs de fechamento&#10;echo &quot;&quot;&#10;echo &quot;6. Últimos logs de fechamento automático:&quot;&#10;echo &quot;=======================================&quot;&#10;docker-compose logs --tail=20 app | grep -i &quot;auction closed automatically&quot; || echo &quot;Nenhum log de fechamento encontrado&quot;&#10;&#10;echo &quot;&quot;&#10;echo &quot; Teste concluído!&quot;&#10;echo &quot;===================&quot;&#10;echo &quot;&quot;&#10;echo &quot; Para acompanhar em tempo real:&quot;&#10;echo &quot;   docker-compose logs -f app | grep -i 'auction closed'&quot;&#10;echo &quot;&quot;&#10;echo &quot; Para verificar status via API:&quot;&#10;echo &quot;   curl 'http://localhost:8080/auction?status=0'  # Ativos&quot;&#10;echo &quot;   curl 'http://localhost:8080/auction?status=1'  # Fechados&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>